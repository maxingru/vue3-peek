<!DOCTYPE html>
<!-- 
解决问题：
  1.修改A属性导致所有副作用函数执行  -> 修改桶
  2.副作用函数依赖问题  -> trigger时先把这个副作用函数从所有相关集合删除再重新执行这个函数，重新触发这个函数内最新的get让这个函数只加入相关的响应式数据的new Set()内
-->
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <div>测试测试</div>
    <script>
      //1.响应式数据:get操作加入桶内，set操作触发桶内的副作用函数
      const obj = { text: "hello", name: "xiaoxiao" }; //我要让这个对象变成响应式对象
      //2.创建一个桶
      // const bucket = new Set();
      const bucket = new WeakMap();

      //统计函数的
      let activeFn = null;
      function addEffect(fn){
        // activeFn = fn;
        // fn();
        //activeFn是当前激活的副作用函数 - 需要记下该函数加入了那个桶内target-key的
        //activeFn之前是函数 ，现在改为对象

        const effectFn = ()=>{
          activeFn = effectFn;  //activeFn必须写在effectFn里面 -> 因为重新执行fn时不能丢失activeFn
          fn();
        }
        effectFn.deps = [];
        //activeFn=effectFn; 不能写在这里
        effectFn(); //执行完
      }



      //1.我已经创建完一个响应式对象data
      //2.现在我要使用这个响应式对象
      //3.这个响应式对象应该满足的要求： [watch/computed/template 和 其它]

      //拉出来get响应式数据 -> 加入对应桶内
      //track
      function track(target, key) {
        if (!activeFn) return target[key]; //仅全局下读取了响应式数据，没有在副作用函数内读取
        let targetValue = bucket.get(target);
        if (!targetValue) {
          bucket.set(target, (targetValue = new Map()));
        }
        const keySet = targetValue.get(key);
        if (!keySet) {
          targetValue.set(key, (keySet = new Set()));
        }
        keySet.add(activeFn); //之前的set:[fn1,fn2,fn3] 现在的set:[fn+fn.deps,fn1+fn1.deps]
        //统计该函数存在哪些set集合中
        activeFn.deps.push(keySet);

        //上面的就是对下面的简化写法  - 多层if嵌套 ->单层
        // if(targetValue){
        //   const keySet = targetValue.get(key);  //set or undefined
        //   if(keySet){
        //     keySet.add(activeFn);
        //   }else{
        //     targetValue.set(key,new Set([activeFn]));
        //   }
        // }else{
        //   bucket.set(target,new Map([[key,new Set([activeFn])]]))
        // }
        // bucket.add(activeFn);
        // }
      }
      //拉出来set响应式数据 -> 重新执行对应的副作用函数
      function trigger(target, key) {
        const targetValue = bucket.get(target);
        const keySet = targetValue?.get(key);
        //在重新执行fn前：先把fn从所有相关set集合中删除 (因为set集合中添加的函数有deps属性，利用这个来删除)
        keySet.forEach((fn) => {
          // 解决的第二个问题：副作用函数遗留问题
          1.书上的这里是不是搞错了？怎么还需要cleanup函数呢？？？
          //先把fn从deps中所有相关的set集合中删除
          fn.deps.forEach((set)=>{
            if(set.includes(fn)){
              set.delete(fn)
            }
          });
          fn();
        });
      }
      const data = new Proxy(obj, {
        get(target, key) {
          //加入桶内
          track(target, key, activeFn);
          console.log("触发get:", key);
          return target[key];
        },
        set(target, key, value) {
          target[key] = value;
          console.log("触发set:", key, value);
          //重新执行对应的副作用函数
          trigger(target, key);
          return true;
        },
      });
      const effect1 = () => {
        const a = data.text;
        // console.log("effect1:", data.text); //这里自动会触发get操作->我只需要执行这个函数就行。
      };
      const effect2 = () => {
        const a = data.text;
        // console.log("effect2:", data.text);
      };

      //1.当前的页面初始化 ->先执行一遍所有get响应式数据的地方->让其自动加入桶内
      //1.页面初始化：

      addEffect(effect1);
      addEffect(effect2);

      //=========================================================下面是页面初始化结束的
      //1.页面初始化完之后：我set响应式数据
      setTimeout(() => {
        //现在的问题在于：当修改响应式对象的任一个属性 -> 都会重新执行桶内的所有函数
        /*
          修改结构如下：
          target
            key1 - fn1,fn2
            key2 - fn1,fn3
          target
            key1 - fn1,fn2

        */
        data.name = "world";
      }, 2000);
    </script>
  </body>
</html>
