# 第一章
## 1.4
1.运行时框架
你写了一个框架，框架提供一个Render函数。
你的Render函数要求一个树形结构的参数。 
用户直接手写一个树形结构的对象 -> 你的框架 -> 渲染页面。

因为只支持用户必须手写一个指定结构的对象，用户也不需要学习额外知识。
你现在的框架就是一个纯运行时框架。

运行时+ 编译时：
因为用户每次提供一个对象抱怨太麻烦 -> 你还提供一个Compiler，支持用户直接传标签。
但需要先编译成你Render函数能接受的格式。 这就是编译时 + 运行时。
既可以让用户直接提供数据对象 不经过编译器。
还可以让用户提供标签-> 框架的Compiler编译后  -> 给Render函数 -> 渲染页面。


用户提供标签 -> 框架的Compiler【分析用户提供信息，返回数据对象】 -> 框架的Render函数 -> 渲染。
或者 
用户直接提供数据对象 -> 框架的Render函数 -> 渲染。


## 1.5
1.你的运行时+ 编译时框架

用户提供标签 - > Complier -> Render -> 渲染。
用户直接提供数据对象 ->Render ->渲染。

框架要求：
-1 提供哪些构建产物(不同环境：开发/生产。不同使用场景：script.src标签直接引入)
    [
        不同使用场景：
        -1 IIFE格式 [vue.global.js -> 被scritp.src直接引入] [rollup对vue打包时指定的format:iife]
        -2 esm格式: [就是vue是es模块构建的] [ ES 模块不能通过 file:// 协议工作] 
        [vue.esm.browser.js   -> 给<script type='module'> import Vue from 'https://unpkg.com/vue@3/dist/vue.esm-browser.js' </script>>使用的。
         vue.esm.bundler.js文件 -> 给打包工具webpack/rollup使用的。 [因为用户会使用打包工具的变量process.env.NODE_ENV来代替源码中的__DEV__ 手动决定构建结果的环境是什么]
        -3 服务端渲染：vue.js代码在Node.js环境下运行。模块格式为commonJS -> .cjs [rollup打包vue时 -> format:'cjs']
            const Vue = require('vue.cjs.js');
    ]
![alt text](image-2.png)
-2 给用户提供哪些特性开关：
    [
        实现：利用rollup.js的预定义常量插件实现：
        1.用户可以开关特性 -> Tree-shaking让关闭特性不包裹在最终结果中。
        2.框架升级时，使用特性开关让用户选择是否使用遗留API [让用户自己使用构建工具vite/webpack来决定特性开关的值=true/false]

    ]
-3 给用户提供错误处理后的-> 而不是让用户自己手动挨个进行try.catch
    [
        //这个要求同样可以用到自己定义的第三方库中。
        将使用该框架时出现的错误捕获 -> 提供一个函数给用户，用户调用这个函数拿到框架内捕获到的错误 -> 上报监控系统 or 不管。
       
    ]

-2 警告提示 [仅__DEV__下打印]
-3 HMR
-3 关闭框架中未使用到的功能减少打包体积。
    [Tree-shaking:前提ESMoudle。
    因为Tree-shaking依赖ESM的静态结构。
    rollup.js和webpack.js都支持Tree-shaking
    Tree-shaking: -1 删除dead code -2 没什么用但产生副作用的代码不能删除。 -3 手动告诉构建工具可以删除这段代码（/*#__PURE__*/ 一般只在顶级作用域添加这个注释，函数内的代码不调用这个函数自然不会产生副作用自然被构建工具自动tree-shaking）
    ]


## 1.6
框架设计思路
1. 如何声明式的描述UI [元素、属性v-bind、事件@、层级]
    -1 模板
    -2 虚拟DOM   [=js对象，虚拟DOM就是用来描述真实DOM元素/组件的一个js对象]
        为了方便使用h函数封装一下，h返回虚拟DOM(js对象)
        return {tag:'div',props:{onClick:handler},children:[{tag,props,''}]}
        = return h('div',{onClick:handler}?,'' or [h('span',"当前值")]);

渲染函数：
就是返回虚拟DOM的一个函数.  (-> 用返回的这个虚拟DOM(js对象)来生成UI); 

2. 渲染器
将虚拟DOM渲染成真实DOM.
原理：递归遍历虚拟DOM 然后调用原生DOM API 生成真实DOM
    在更新阶段，使用diff算法查找虚拟DOM中的变更点 只更新需要更新的地方
-1 创建节点    
    [1.创建元素2.遍历属性(添加属性和事件)3.遍历children]
-2 更新节点阶段 
    [#这里后文。只更新必要的地方，不会重新再创建一遍=============================]
    虚拟DOM中的变量可能会变化 ->渲染函数需要查找哪些是变更点




3. 组件
组件就是一组DOM元素的封装。 //虚拟DOM来描述组件。
<!-- 虚拟DOM就是描述真实DOM元素/组件的一个js对象。 -->
组件看成一个函数，这个函数返回虚拟DOM就行。
组件也可以看成一个对象，对象有一个函数，返回虚拟DOM

渲染器处理组件：本质还是将虚拟DOM ->真实DOM。先将组件还原成虚拟DOM就和处理普通标签一样了。

4. 模板
使用虚拟DOM 或者 模板 都是声明式的描述UI

编译器：
将模板编译成渲染函数 (并且打上静态属性、动态属性等标志)
[渲染函数：render(){return h('div',{},'click me')});

[流程：模板->渲染函数->虚拟DOM->渲染器->真实DOM]
模板的工作原理 = Vue渲染页面的流程：
    在组件内：先将template 经过编译器 编译成 <script>内的渲染函数  (或者你直接提供渲染函数，不写模板)
             然后渲染器 将渲染函数返回的虚拟DOM渲染为真实DOM
             




5. vue由各个模板之间联系组成
渲染器：将虚拟DOM -> 真实DOM
    -1 创建阶段
    -2 更新阶段 [这里的更新阶段就需要自动查找虚拟DOM中有哪些是变量且变量改变了]
编译器：将模板 -> 渲染函数

因为渲染器挨个查找虚拟DOM中哪些是变量麻烦 
->
所以让编译器在将模板编译成渲染函数时，自动将哪些是动态属性打上标签。
然后传给渲染器中附带上这些信息


# 问题
1.vue使用rollup.js打包？









